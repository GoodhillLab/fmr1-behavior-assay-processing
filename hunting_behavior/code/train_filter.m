function H = train_filter(data_path,mask,ann,bg,feat_type,params,v)
%TRAIN_MOSSE_FILTER Trains MOSSE filter stack on annotated frames
%   Detailed explanation goes here

% Extract and pre-process training frames
N = size(ann,1);
width = v(1).Width+1;
height = v(1).Height+1;
f = zeros([height,width,N,2],'single'); % 4th dimension is for swim bladder and eye-midpoint
x0 = (width+1)/2;
y0 = (height+1)/2;
for n = 1:N
    % Get frame
    file_name = fullfile(data_path, ann.file_name{n});
    k = ann.frame(n);
    fc = single(read(v(j),k));
    % Foreground extraction and filtering
    j = ann.movie_number(n);
    fg = (fc-bg(j).mean)./bg(j).std > bg(j).thr;
    fg = fg & (fc > params.thr); % foreground mask filtered for low intensity noise
    fg = fg & mask;
    fg = bwareafilt(fg,1); % foreground mask filtered to remove small connected components
    fc = fc.*fg;
    fc = padarray(fc,[height,width]-size(fc),0,'post');
    f(:,:,n,1) = fc;
    f(:,:,n,2) = fc;
    % Translate to centre
    tx = x0 - ann.swim_bladder_x(n);
    ty = y0 - ann.swim_bladder_y(n);
    f(:,:,n,1) = imtranslate(f(:,:,n,1),[tx,ty],'OutputView','same', ...
        'FillValues',0);
    tx = x0 - ann.eye_midpoint_x(n);
    ty = y0 - ann.eye_midpoint_y(n);
    f(:,:,n,2) = imtranslate(f(:,:,n,2),[tx,ty],'OutputView','same', ...
        'FillValues',0);
    % Rotate to 0 deg
    dx = ann.eye_midpoint_x(n) - ann.swim_bladder_x(n);
    dy = ann.eye_midpoint_y(n) - ann.swim_bladder_y(n);
    theta = atan2d(dy,dx);
    f(:,:,n,1) = imrotate(f(:,:,n,1),theta,'bilinear','crop');
    f(:,:,n,2) = imrotate(f(:,:,n,2),theta,'bilinear','crop');
end

% Initialise feature array and filter stack
sz = params.sz;
pow2 = 2.^(0:12);
if strcmp(feat_type,'px')
    n_feat = 1;
    z = zeros([sz,sz,n_feat,N],'single');
    zp = min(pow2(pow2>=sz));
elseif strcmp(feat_type,'hog')
    n_feat = 3*params.n_orients+5-1;
    sz_hog = floor(params.sz/params.bin_size);
    z = zeros([sz_hog,sz_hog,n_feat,N],'single');
    zp = min(pow2(pow2>=sz_hog));
end
H = zeros([zp,zp,n_feat,length(params.rot_angle), ...
    length(params.scale_coef),2],'single');

% Loop over tracking points
for p = 1:2
    % Loop over scale transformations
    for scale_idx = 1:length(params.scale_coef)
        % Loop over rotational transformations
        for rot_idx = 1:length(params.rot_angle)
            % fprintf('%g, %g, %g\n',p,scale_idx,rot_idx)
            % Scale (force to odd)
            scale_width = width*params.scale_coef(scale_idx);
            if ~mod(floor(scale_width),2)
                scale_width = floor(scale_width)+1;
            else
                scale_width = floor(scale_width);
            end
            fc = imresize(squeeze(f(:,:,:,p)),[height,scale_width]);
            % Pad
            pd = [height,width,N]-size(fc);
            fc = padarray(fc,pd/2,0);
            % Rotate
            fc = imrotate(fc,params.rot_angle(rot_idx),'bilinear','crop');
            % Crop
            fc = fc((y0-(sz-1)/2):(y0+(sz-1)/2), ...
                (x0-(sz-1)/2):(x0+(sz-1)/2),:);
            % Get features
            if strcmp(feat_type,'px')
                z(:,:,1,:) = fc;
            elseif strcmp(feat_type,'hog')
                % HOG transform
                for j=1:N
                    hog = fhog(squeeze(fc(:,:,j)), params.bin_size, params.n_orients);
                    hog(:,:,end) = [];  %remove all-zeros channel ("truncation feature")
                    z(:,:,:,j) = hog;
                end
            end
            % Loop over features
            for feat_idx = 1:n_feat
                % Train
                H(:,:,feat_idx,rot_idx,scale_idx,p) = train_MOSSE( ...
                    squeeze(z(:,:,feat_idx,:)), ...
                    params.sigma, ...
                    params.eps, ...
                    zp, ...
                    params.aff_angles);
            end
        end
    end
end
end

function H = train_MOSSE(z,sigma,eps,zp,angles)
sz = size(z,1);
x0 = (sz+1)/2;
y0 = (sz+1)/2;
for j=1:size(size(z,3),3)
    f = z(:,:,j);
    % Generate synthetic target
    [x,y] = meshgrid(1:sz,1:sz);
    g = exp(-((x(:)-x0).^2+(y(:)-y0).^2)/sigma^2);
    g = reshape(g,sz,sz);
    G = fft2(g,zp,zp);
    % FFT
    F = fft2(f,zp,zp);
    % Train filter
    if j==1
        N = G.*conj(F);
        D = F.*conj(F);
    else
        N = N + G.*conj(F);
        D = D + F.*conj(F);
    end
    % Enhance filter using synthetic data generated by affine transformations
    for k = 1:length(angles)
        f = imrotate(f,-angles(k),'bilinear','crop');
        F = fft2(f,zp,zp);
        N = N + G.*conj(F);
        D = D + F.*conj(F);
    end
end
H = N./(D+eps);
end